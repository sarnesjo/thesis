\documentclass[a4paper,11pt]{kth-mag}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{modifications}
\usepackage{hyperref}

\hypersetup{colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black}

\title{Using binary decision diagrams to determine program equivalence in a superoptimizer}
\subtitle{}
\foreigntitle{Att använda binära beslutsdiagram för att avgöra ekvivalens mellan program i en superoptimerare}
\author{Jesper Särnesjö}
\date{}
\blurb{Master's Thesis at CSC \\ Supervisor: Torbjörn Granlund \\ Examiner: Johan Håstad}
\trita{TRITA xxx yyyy-nn}

\begin{document}

\frontmatter

\pagestyle{empty}

\removepagenumbers

\maketitle

\selectlanguage{english}

\begin{abstract}
\end{abstract}

\clearpage

\begin{foreignabstract}{swedish}
\end{foreignabstract}

\clearpage

\tableofcontents*

\mainmatter

\pagestyle{newchap}

\chapter{Introduction}

\chapter{Background}

\section{Superoptimizers}

A superoptimizer is a tool for finding the optimal program computing a given function.  % straight-line, loop-free
Typically, it takes as its input a description of a program, and yields as its output an equivalent, but optimal, program.
Here, two programs are considered equivalent if they always yield identical output given identical and valid input.

There are many possible measures of the optimality of a program.
The arguably simplest one is \emph{program length}, the number of instructions in the program.
Using this measure, a program is considered optimal if no equivalent program contains fewer instructions.
A similar measure is \emph{program size}, the number of bytes required to store the program. % difference only meaningful for variable instruction length architectures
Another measure is \emph{execution time}, the number of clock cycles it takes for the program to run from start to finish. % different and more complicated because...
The measures mentioned appear to be the ones used in practice, although any quantifiable property of a program could be used. % memory or power usage

The search strategy typically employed by superoptimizers, is to exhaustively generate potentially optimal candidate programs and test them for equivalence with the input program.
This works particularly well when the measure of optimality is program length, as the superoptimizer may then begin by generating and testing all programs of length 1, followed by those of length 2, and so on.
The first program found to be equivalent to the input program will necessarily be an optimal program.

It should be noted that exhaustive search over the space of all potentially optimal programs is very slow.
The number of programs of length $n$ using an instruction set consisting of $b$ instructions is $b^n$. % effective
For this reason, it is crucial to aggressively prune the search tree, ignoring programs which cannot possibly be optimal.

% determining equivalence

\subsection{History}

The term superoptimizer was coined by Henry Massalin in a paper published in 1987.
% Motorola 68020
% subset, no mem
% program length, exhaustive search
% equivalence tests: boolean -> 40/s, probabilistic -> 50k/s (executes code, host instruction set only)
% pruning: subsequence must also be optimal (only true for program size metric)
% applications
\cite{massalin87}

% GSO, the GNU superoptimizer
% like massalin: program length, probabilistic
% simulates instead of executes -> supports many architectures
% machine: registers + carry bit, no mem
% input: goal function compiled in
% pruning
% branching factor "between 100 and 1000"
% source code available
\cite{granlund92}

% Denali
% first publication in 2002
% execution time, provably correct equivalence, multiple assignments
% matcher
% solver
% input in somewhat C-like DSL
\cite{joshi02}

% Denali-2
% program length
% theoretical description of algo only, no implementation
\cite{joshi06}

% Bansal
% peephole superoptimizer
% fully automatic
% input: binary
% output: replacement rules
% execution time, program size
% x86
% pruning: meet-in-the-middle
% interesting application: binary translator
% source code available
\cite{bansal_thesis}

% TOAST, Total Optimisation using Answer Set Technology
\cite{crick_thesis}

\section{Binary decision diagrams}

\chapter{...}

% machine: registers,flags

\section{...}

\subsection{Flag control}

% stc,clc,cmc

\subsection{Data transfer}

% mov,cmov

\subsection{Logic}

% and,or,xor
% not (one's complement negation)

\subsection{Addition and subtraction}

% add
% adc,sub,sbb,cmp,inc,dec all similar
% neg (two's complement negation): not+inc

\subsection{Multiplication}

% most difficult: multiplication

\bibliographystyle{ieeetr}
\bibliography{thesis}

\appendix
\addappheadtotoc

\end{document}
